{"version":3,"sources":["../node_modules/refractor/lang/parigp.js"],"names":["parigp","Prism","languages","comment","string","pattern","greedy","keyword","keywords","map","split","join","RegExp","function","number","lookbehind","operator","punctuation","module","exports","displayName","aliases"],"mappings":"yHAMA,SAASA,EAAOC,GACdA,EAAMC,UAAUF,OAAS,CACvBG,QAAS,0BACTC,OAAQ,CACNC,QAAS,wBACTC,QAAQ,GAKVC,QAAS,WACP,IAAIC,EAAW,CAAC,aAAc,QAAS,WAAY,UAAW,SAAU,QAAS,eAAgB,SAAU,SAAU,UAAW,WAAY,UAAW,cAAe,SAAU,MAAO,QAAS,KAAM,QAAS,KAAM,OAAQ,SAAU,QAAS,SAIhP,OAHAA,EAAWA,EAASC,KAAI,SAAUF,GAChC,OAAOA,EAAQG,MAAM,IAAIC,KAAK,SAC7BA,KAAK,KACDC,OAAO,SAAWJ,EAAW,QAL7B,GAOTK,SAAU,4BACVC,OAAQ,CAENT,QAAS,gHACTU,YAAY,GAEdC,SAAU,sLACVC,YAAa,mBA5BjBC,EAAOC,QAAUnB,EACjBA,EAAOoB,YAAc,SACrBpB,EAAOqB,QAAU","file":"static/js/react-syntax-highlighter_languages_refractor_parigp.99896652.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = parigp;\nparigp.displayName = 'parigp';\nparigp.aliases = [];\n\nfunction parigp(Prism) {\n  Prism.languages.parigp = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n      greedy: true\n    },\n    // PARI/GP does not care about white spaces at all\n    // so let's process the keywords to build an appropriate regexp\n    // (e.g. \"b *r *e *a *k\", etc.)\n    keyword: function () {\n      var keywords = ['breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x', 'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime', 'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if', 'local', 'my', 'next', 'return', 'until', 'while'];\n      keywords = keywords.map(function (keyword) {\n        return keyword.split('').join(' *');\n      }).join('|');\n      return RegExp('\\\\b(?:' + keywords + ')\\\\b');\n    }(),\n    function: /\\b\\w(?:[\\w ]*\\w)?(?= *\\()/,\n    number: {\n      // The lookbehind and the negative lookahead prevent from breaking the .. operator\n      pattern: /((?:\\. *\\. *)?)(?:\\b\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *(?:[+-] *)?\\d(?: *\\d)*)?/i,\n      lookbehind: true\n    },\n    operator: /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n    punctuation: /[\\[\\]{}().,:;|]/\n  };\n}"],"sourceRoot":""}