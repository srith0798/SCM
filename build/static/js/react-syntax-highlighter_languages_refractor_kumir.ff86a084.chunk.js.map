{"version":3,"sources":["../node_modules/refractor/lang/kumir.js"],"names":["kumir","Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","comment","prolog","greedy","string","boolean","lookbehind","alias","type","keyword","name","number","punctuation","kum","module","exports","displayName","aliases"],"mappings":"yHAMA,SAASA,EAAMC,IAIb,SAAWA,GAMT,IAAIC,EAAQ,sDAAsDC,OASlE,SAASC,EAAOC,EAASC,GACvB,OAAOC,OAAOF,EAAQG,QAAQ,WAAYN,GAAQI,GAGpDL,EAAMQ,UAAUT,MAAQ,CACtBU,QAAS,CACPL,QAAS,QAEXM,OAAQ,CACNN,QAAS,MACTO,QAAQ,GAEVC,OAAQ,CACNR,QAAS,0BACTO,QAAQ,GAEVE,QAAS,CACPT,QAASD,EAAO,kEAAyCD,QACzDY,YAAY,GAEd,gBAAiB,CACfV,QAASD,EAAO,yEAA2CD,QAC3DY,YAAY,EACZC,MAAO,WAET,kBAAmB,CACjBX,QAASD,EAAO,uDAAmCD,QACnDY,YAAY,EACZC,MAAO,WAETC,KAAM,CAAC,CACLZ,QAASD,EAAO,6JAAmED,QACnFY,YAAY,EACZC,MAAO,WACN,CACDX,QAASD,EAAO,8JAA0DD,QAC1EY,YAAY,EACZC,MAAO,cAQTE,QAAS,CACPb,QAASD,EAAO,84BAAqPD,QACrQY,YAAY,GAIdI,KAAM,CAEJd,QAASD,EAAO,2EAA2ED,QAC3FY,YAAY,GAIdK,OAAQ,CACNf,QAASD,EAAO,2FAA2FD,OAAQ,KACnHY,YAAY,GAIdM,YAAa,iBAOb,gBAAiB,CACfhB,QAAS,0BACTW,MAAO,aAGXf,EAAMQ,UAAUa,IAAMrB,EAAMQ,UAAUT,MA3FxC,CA4FGC,GApGLsB,EAAOC,QAAUxB,EACjBA,EAAMyB,YAAc,QACpBzB,EAAM0B,QAAU,CAAC","file":"static/js/react-syntax-highlighter_languages_refractor_kumir.ff86a084.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = kumir;\nkumir.displayName = 'kumir';\nkumir.aliases = ['kum'];\n\nfunction kumir(Prism) {\n  /* eslint-disable regexp/no-dupe-characters-character-class */\n  ;\n\n  (function (Prism) {\n    /**\n     * Regular expression for characters that are not allowed in identifiers.\n     *\n     * @type {string}\n     */\n    var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n    /**\n     * Surround a regular expression for IDs with patterns for non-ID sequences.\n     *\n     * @param {string} pattern A regular expression for identifiers.\n     * @param {string} [flags] The regular expression flags.\n     * @returns {RegExp} A wrapped regular expression for identifiers.\n     */\n\n    function wrapId(pattern, flags) {\n      return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n    }\n\n    Prism.languages.kumir = {\n      comment: {\n        pattern: /\\|.*/\n      },\n      prolog: {\n        pattern: /#.*/,\n        greedy: true\n      },\n      string: {\n        pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n        greedy: true\n      },\n      boolean: {\n        pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n      'operator-word': {\n        pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'system-variable': {\n        pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      type: [{\n        pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'builtin'\n      }, {\n        pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'important'\n      }],\n\n      /**\n       * Should be performed after searching for type names because of \"таб\".\n       * \"таб\" is a reserved word, but never used without a preceding type name.\n       * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n       */\n      keyword: {\n        pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for reserved words. */\n      name: {\n        // eslint-disable-next-line regexp/no-super-linear-backtracking\n        pattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for names. */\n      number: {\n        pattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for words. */\n      punctuation: /:=|[(),:;\\[\\]]/,\n\n      /**\n       * Should be performed after searching for\n       * - numeric constants (because of \"+\" and \"-\");\n       * - punctuation marks (because of \":=\" and \"=\").\n       */\n      'operator-char': {\n        pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n        alias: 'operator'\n      }\n    };\n    Prism.languages.kum = Prism.languages.kumir;\n  })(Prism);\n}"],"sourceRoot":""}