{"version":3,"sources":["../node_modules/refractor/lang/zig.js"],"names":["zig","Prism","literal","str","keyword","IDENTIFIER","source","ALIGN","TYPE","replace","languages","comment","pattern","alias","string","lookbehind","greedy","builtin","label","RegExp","inside","function","number","boolean","operator","punctuation","forEach","obj","module","exports","displayName","aliases"],"mappings":"yHAMA,SAASA,EAAIC,IAGX,SAAWA,GACT,SAASC,EAAQC,GACf,OAAO,WACL,OAAOA,GAIX,IAAIC,EAAU,sVACVC,EAAa,SAAWD,EAAQE,OAAS,kBACzCC,EAAQ,oCAAoCD,OAG5CE,EAAO,sBAFU,0GAA0GF,OAAOG,QAAQ,WAAYP,EAAQK,IAE9G,SADlC,2DAA2DD,OAAOG,QAAQ,QAASP,EAAQG,IAChC,KAkB7EJ,EAAMS,UAAUV,IAAM,CACpBW,QAAS,CAAC,CACRC,QAAS,UACTC,MAAO,eACN,WACHC,OAAQ,CAAC,CAEPF,QAAS,oCACTG,YAAY,EACZC,QAAQ,GACP,CAEDJ,QAAS,iDACTG,YAAY,EACZC,QAAQ,GACP,CAEDJ,QAAS,wEACTG,YAAY,EACZC,QAAQ,IAEVC,QAAS,wBACTC,MAAO,CACLN,QAAS,4EACTG,YAAY,GAEd,aAAc,CACd,8EAA+E,CAI7EH,QAASO,OAAO,0EAA0Eb,OAAOG,QAAQ,UAAWP,EAAQM,IAAOC,QAAQ,WAAYP,EAAQK,KAC/JQ,YAAY,EACZK,OAAQ,MAEP,CAEDR,QAASO,OAAO,uCAAuCb,OAAOG,QAAQ,UAAWP,EAAQM,IAAOC,QAAQ,WAAYP,EAAQK,KAC5HQ,YAAY,EACZK,OAAQ,OAGV,gBAAiB,CACfR,QAAS,oKACTC,MAAO,WAETT,QAASA,EACTiB,SAAU,uBACVC,OAAQ,mHACRC,QAAS,qBACTC,SAAU,6EACVC,YAAa,iBAEfxB,EAAMS,UAAUV,IAAI,cAAc0B,SAAQ,SAAUC,GAC/B,OAAfA,EAAIP,SACNO,EAAIP,OAASnB,EAAMS,UAAUV,QArFnC,CAwFGC,GA/FL2B,EAAOC,QAAU7B,EACjBA,EAAI8B,YAAc,MAClB9B,EAAI+B,QAAU","file":"static/js/react-syntax-highlighter_languages_refractor_zig.59ded388.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = zig;\nzig.displayName = 'zig';\nzig.aliases = [];\n\nfunction zig(Prism) {\n  ;\n\n  (function (Prism) {\n    function literal(str) {\n      return function () {\n        return str;\n      };\n    }\n\n    var keyword = /\\b(?:align|allowzero|and|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n    var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n    var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n    var PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n    var SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n    var TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n    /*\n     * A simplified grammar for Zig compile time type literals:\n     *\n     * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n     *\n     * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n     *\n     * PREFIX_TYPE_OP = \"?\"\n     *                | \\b \"promise\" \"->\"\n     *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n     *\n     * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n     *\n     * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n     *\n     */\n\n    Prism.languages.zig = {\n      comment: [{\n        pattern: /\\/{3}.*/,\n        alias: 'doc-comment'\n      }, /\\/{2}.*/],\n      string: [{\n        // \"string\" and c\"string\"\n        pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n        lookbehind: true,\n        greedy: true\n      }, {\n        // multiline strings and c-strings\n        pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n        lookbehind: true,\n        greedy: true\n      }, {\n        // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n        pattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n        lookbehind: true,\n        greedy: true\n      }],\n      builtin: /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n      label: {\n        pattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n        lookbehind: true\n      },\n      'class-name': [// const Foo = struct {};\n      /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/, {\n        // const x: i32 = 9;\n        // var x: Bar;\n        // fn foo(x: bool, y: f32) void {}\n        pattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }, {\n        // extern fn foo(x: f64) f64; (optional alignment)\n        pattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }],\n      'builtin-types': {\n        pattern: /\\b(?:anyerror|bool|c_u?(?:short|int|long|longlong)|c_longdouble|c_void|comptime_(?:float|int)|[iu](?:8|16|32|64|128|size)|f(?:16|32|64|128)|noreturn|type|void)\\b/,\n        alias: 'keyword'\n      },\n      keyword: keyword,\n      function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n      number: /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      operator: /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n      punctuation: /[.:,;(){}[\\]]/\n    };\n    Prism.languages.zig['class-name'].forEach(function (obj) {\n      if (obj.inside === null) {\n        obj.inside = Prism.languages.zig;\n      }\n    });\n  })(Prism);\n}"],"sourceRoot":""}