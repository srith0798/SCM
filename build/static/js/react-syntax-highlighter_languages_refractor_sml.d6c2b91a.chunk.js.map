{"version":3,"sources":["../node_modules/refractor/lang/sml.js"],"names":["sml","Prism","keywords","languages","comment","string","pattern","greedy","RegExp","source","replace","lookbehind","inside","function","keyword","variable","number","word","alias","boolean","operator","punctuation","smlnj","module","exports","displayName","aliases"],"mappings":"yHAMA,SAASA,EAAIC,IAKX,SAAWA,GACT,IAAIC,EAAW,0PACfD,EAAME,UAAUH,IAAM,CAEpBI,QAAS,4EACTC,OAAQ,CACNC,QAAS,sBACTC,QAAQ,GAEV,aAAc,CAAC,CAObD,QAASE,OAAO,2HAA2HC,OAAOC,QAAQ,eAAe,WACvK,MAAO,iBAAiBD,UACvBC,QAAQ,eAAe,WACxB,MAAO,6FAA6FD,UACnGC,QAAQ,cAAc,WACvB,MAAO,+BAA+BD,UACrCC,QAAQ,cAAc,WACvB,OAAOR,EAASO,UACd,KACJE,YAAY,EACZJ,QAAQ,EACRK,OAAQ,MAEP,CACDN,QAAS,yFACTK,YAAY,IAEdE,SAAU,CACRP,QAAS,qCACTK,YAAY,GAEdG,QAASZ,EACTa,SAAU,CACRT,QAAS,oBACTK,YAAY,GAEdK,OAAQ,iDACRC,KAAM,CACJX,QAAS,2BACTY,MAAO,YAETC,QAAS,sBACTC,SAAU,4CACVC,YAAa,kBAEfpB,EAAME,UAAUH,IAAI,cAAc,GAAGY,OAASX,EAAME,UAAUH,IAC9DC,EAAME,UAAUmB,MAAQrB,EAAME,UAAUH,IApD1C,CAqDGC,GA9DLsB,EAAOC,QAAUxB,EACjBA,EAAIyB,YAAc,MAClBzB,EAAI0B,QAAU,CAAC","file":"static/js/react-syntax-highlighter_languages_refractor_sml.d6c2b91a.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = sml;\nsml.displayName = 'sml';\nsml.aliases = ['smlnj'];\n\nfunction sml(Prism) {\n  // https://smlfamily.github.io/sml97-defn.pdf\n  // https://people.mpi-sws.org/~rossberg/sml.html\n  ;\n\n  (function (Prism) {\n    var keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n    Prism.languages.sml = {\n      // allow one level of nesting\n      comment: /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n      string: {\n        pattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': [{\n        // This is only an approximation since the real grammar is context-free\n        //\n        // Why the main loop so complex?\n        // The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n        // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n        // followed by a long identifier.\n        pattern: RegExp(/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function () {\n          return /\\s*(?:[*,]|->)/.source;\n        }).replace(/<TERMINAL>/g, function () {\n          return /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n        }).replace(/<LONG-ID>/g, function () {\n          return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source;\n        }).replace(/<KEYWORD>/g, function () {\n          return keywords.source;\n        }), 'i'),\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      }, {\n        pattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      }],\n      function: {\n        pattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      },\n      keyword: keywords,\n      variable: {\n        pattern: /(^|[^\\w'])'[\\w']*/,\n        lookbehind: true\n      },\n      number: /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n      word: {\n        pattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n        alias: 'constant'\n      },\n      boolean: /\\b(?:false|true)\\b/i,\n      operator: /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n      punctuation: /[(){}\\[\\].:,;]/\n    };\n    Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n    Prism.languages.smlnj = Prism.languages.sml;\n  })(Prism);\n}"],"sourceRoot":""}