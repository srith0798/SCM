{"version":3,"sources":["../node_modules/refractor/lang/ftl.js","../node_modules/refractor/lang/markup-templating.js"],"names":["refractorMarkupTemplating","ftl","Prism","register","FTL_EXPR","source","i","replace","comment","string","pattern","greedy","RegExp","inside","interpolation","lookbehind","alias","rest","keyword","boolean","function","number","operator","punctuation","languages","directive","content","hooks","add","env","buildPlaceholders","tokenizePlaceholders","module","exports","displayName","aliases","markupTemplating","getPlaceholder","language","index","toUpperCase","Object","defineProperties","value","placeholderPattern","replaceFilter","tokenStack","code","match","placeholder","length","indexOf","grammar","markup","j","keys","walkTokens","tokens","token","k","t","s","before","substring","middle","Token","tokenize","after","replacement","push","apply","splice","concat"],"mappings":"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","file":"static/js/react-syntax-highlighter_languages_refractor_ftl.74fec520.chunk.js","sourcesContent":["'use strict';\n\nvar refractorMarkupTemplating = require('./markup-templating.js');\n\nmodule.exports = ftl;\nftl.displayName = 'ftl';\nftl.aliases = [];\n\nfunction ftl(Prism) {\n  Prism.register(refractorMarkupTemplating);\n\n  (function (Prism) {\n    // https://freemarker.apache.org/docs/dgui_template_exp.html\n    // FTL expression with 4 levels of nesting supported\n    var FTL_EXPR = /[^<()\"']|\\((?:<expr>)*\\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|\"(?:[^\\\\\"]|\\\\.)*\"|'(?:[^\\\\']|\\\\.)*'/.source;\n\n    for (var i = 0; i < 2; i++) {\n      FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function () {\n        return FTL_EXPR;\n      });\n    }\n\n    FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\\s\\S]/.source);\n    var ftl = {\n      comment: /<#--[\\s\\S]*?-->/,\n      string: [{\n        // raw string\n        pattern: /\\br(\"|')(?:(?!\\1)[^\\\\]|\\\\.)*\\1/,\n        greedy: true\n      }, {\n        pattern: RegExp(/(\"|')(?:(?!\\1|\\$\\{)[^\\\\]|\\\\.|\\$\\{(?:(?!\\})(?:<expr>))*\\})*\\1/.source.replace(/<expr>/g, function () {\n          return FTL_EXPR;\n        })),\n        greedy: true,\n        inside: {\n          interpolation: {\n            pattern: RegExp(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\$\\{(?:(?!\\})(?:<expr>))*\\}/.source.replace(/<expr>/g, function () {\n              return FTL_EXPR;\n            })),\n            lookbehind: true,\n            inside: {\n              'interpolation-punctuation': {\n                pattern: /^\\$\\{|\\}$/,\n                alias: 'punctuation'\n              },\n              rest: null\n            }\n          }\n        }\n      }],\n      keyword: /\\b(?:as)\\b/,\n      boolean: /\\b(?:true|false)\\b/,\n      'builtin-function': {\n        pattern: /((?:^|[^?])\\?\\s*)\\w+/,\n        lookbehind: true,\n        alias: 'function'\n      },\n      function: /\\b\\w+(?=\\s*\\()/,\n      number: /\\b\\d+(?:\\.\\d+)?\\b/,\n      operator: /\\.\\.[<*!]?|->|--|\\+\\+|&&|\\|\\||\\?{1,2}|[-+*/%!=<>]=?|\\b(?:gt|gte|lt|lte)\\b/,\n      punctuation: /[,;.:()[\\]{}]/\n    };\n    ftl.string[1].inside.interpolation.inside.rest = ftl;\n    Prism.languages.ftl = {\n      'ftl-comment': {\n        // the pattern is shortened to be more efficient\n        pattern: /^<#--[\\s\\S]*/,\n        alias: 'comment'\n      },\n      'ftl-directive': {\n        pattern: /^<[\\s\\S]+>$/,\n        inside: {\n          directive: {\n            pattern: /(^<\\/?)[#@][a-z]\\w*/i,\n            lookbehind: true,\n            alias: 'keyword'\n          },\n          punctuation: /^<\\/?|\\/?>$/,\n          content: {\n            pattern: /\\s*\\S[\\s\\S]*/,\n            alias: 'ftl',\n            inside: ftl\n          }\n        }\n      },\n      'ftl-interpolation': {\n        pattern: /^\\$\\{[\\s\\S]*\\}$/,\n        inside: {\n          punctuation: /^\\$\\{|\\}$/,\n          content: {\n            pattern: /\\s*\\S[\\s\\S]*/,\n            alias: 'ftl',\n            inside: ftl\n          }\n        }\n      }\n    };\n    Prism.hooks.add('before-tokenize', function (env) {\n      // eslint-disable-next-line regexp/no-useless-lazy\n      var pattern = RegExp(/<#--[\\s\\S]*?-->|<\\/?[#@][a-zA-Z](?:<expr>)*?>|\\$\\{(?:<expr>)*?\\}/.source.replace(/<expr>/g, function () {\n        return FTL_EXPR;\n      }), 'gi');\n      Prism.languages['markup-templating'].buildPlaceholders(env, 'ftl', pattern);\n    });\n    Prism.hooks.add('after-tokenize', function (env) {\n      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'ftl');\n    });\n  })(Prism);\n}","'use strict';\n\nmodule.exports = markupTemplating;\nmarkupTemplating.displayName = 'markupTemplating';\nmarkupTemplating.aliases = [];\n\nfunction markupTemplating(Prism) {\n  ;\n\n  (function (Prism) {\n    /**\n     * Returns the placeholder for the given language id and index.\n     *\n     * @param {string} language\n     * @param {string|number} index\n     * @returns {string}\n     */\n    function getPlaceholder(language, index) {\n      return '___' + language.toUpperCase() + index + '___';\n    }\n\n    Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n      buildPlaceholders: {\n        /**\n         * Tokenize all inline templating expressions matching `placeholderPattern`.\n         *\n         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n         * `true` will be replaced.\n         *\n         * @param {object} env The environment of the `before-tokenize` hook.\n         * @param {string} language The language id.\n         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n         * @param {(match: string) => boolean} [replaceFilter]\n         */\n        value: function value(env, language, placeholderPattern, replaceFilter) {\n          if (env.language !== language) {\n            return;\n          }\n\n          var tokenStack = env.tokenStack = [];\n          env.code = env.code.replace(placeholderPattern, function (match) {\n            if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n              return match;\n            }\n\n            var i = tokenStack.length;\n            var placeholder; // Check for existing strings\n\n            while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n              ++i;\n            } // Create a sparse array\n\n\n            tokenStack[i] = match;\n            return placeholder;\n          }); // Switch the grammar to markup\n\n          env.grammar = Prism.languages.markup;\n        }\n      },\n      tokenizePlaceholders: {\n        /**\n         * Replace placeholders with proper tokens after tokenizing.\n         *\n         * @param {object} env The environment of the `after-tokenize` hook.\n         * @param {string} language The language id.\n         */\n        value: function value(env, language) {\n          if (env.language !== language || !env.tokenStack) {\n            return;\n          } // Switch the grammar back\n\n\n          env.grammar = Prism.languages[language];\n          var j = 0;\n          var keys = Object.keys(env.tokenStack);\n\n          function walkTokens(tokens) {\n            for (var i = 0; i < tokens.length; i++) {\n              // all placeholders are replaced already\n              if (j >= keys.length) {\n                break;\n              }\n\n              var token = tokens[i];\n\n              if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n                var k = keys[j];\n                var t = env.tokenStack[k];\n                var s = typeof token === 'string' ? token : token.content;\n                var placeholder = getPlaceholder(language, k);\n                var index = s.indexOf(placeholder);\n\n                if (index > -1) {\n                  ++j;\n                  var before = s.substring(0, index);\n                  var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                  var after = s.substring(index + placeholder.length);\n                  var replacement = [];\n\n                  if (before) {\n                    replacement.push.apply(replacement, walkTokens([before]));\n                  }\n\n                  replacement.push(middle);\n\n                  if (after) {\n                    replacement.push.apply(replacement, walkTokens([after]));\n                  }\n\n                  if (typeof token === 'string') {\n                    tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                  } else {\n                    token.content = replacement;\n                  }\n                }\n              } else if (token.content\n              /* && typeof token.content !== 'string' */\n              ) {\n                walkTokens(token.content);\n              }\n            }\n\n            return tokens;\n          }\n\n          walkTokens(env.tokens);\n        }\n      }\n    });\n  })(Prism);\n}"],"sourceRoot":""}