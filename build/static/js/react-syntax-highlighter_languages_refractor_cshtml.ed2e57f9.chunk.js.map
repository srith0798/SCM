{"version":3,"sources":["../node_modules/refractor/lang/cshtml.js","../node_modules/refractor/lang/csharp.js"],"names":["refractorCsharp","cshtml","Prism","register","commentLike","source","stringLike","nested","pattern","depthLog2","i","replace","round","square","curly","angle","tagAttrs","tagContent","tagRegion","languages","extend","cs","alias","inside","insertBefore","html","RegExp","greedy","csharp","block","join","lookbehind","keyword","directive","value","razor","module","exports","displayName","aliases","replacements","m","index","re","flags","keywordKinds","keywordsToPattern","words","trim","typeDeclarationKeywords","keywords","nonTypeKeywords","nonContextualKeywords","generic","nestedRound","name","genericName","identifier","array","typeExpressionWithoutTuple","tupleElement","tuple","typeExpression","typeInside","punctuation","character","regularString","verbatimString","string","number","operator","range","namespace","function","preprocessor","regularStringOrCharacter","regularStringCharacterOrComment","roundExpression","attrTarget","attr","attribute","target","formatString","mInterpolationRound","mInterpolation","sInterpolationRound","sInterpolation","createInterpolationInside","interpolation","interpolationRound","expression","char","dotnet"],"mappings":"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","file":"static/js/react-syntax-highlighter_languages_refractor_cshtml.ed2e57f9.chunk.js","sourcesContent":["'use strict';\n\nvar refractorCsharp = require('./csharp.js');\n\nmodule.exports = cshtml;\ncshtml.displayName = 'cshtml';\ncshtml.aliases = ['razor'];\n\nfunction cshtml(Prism) {\n  Prism.register(refractorCsharp) // Docs:\n  // https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio\n  // https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0\n  ;\n\n  (function (Prism) {\n    var commentLike = /\\/(?![/*])|\\/\\/.*[\\r\\n]|\\/\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\//.source;\n    var stringLike = /@(?!\")|\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|@\"(?:[^\\\\\"]|\"\"|\\\\[\\s\\S])*\"(?!\")/.source + '|' + /'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))/.source;\n    /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */\n\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<self>/g, function () {\n          return '(?:' + pattern + ')';\n        });\n      }\n\n      return pattern.replace(/<self>/g, '[^\\\\s\\\\S]').replace(/<str>/g, '(?:' + stringLike + ')').replace(/<comment>/g, '(?:' + commentLike + ')');\n    }\n\n    var round = nested(/\\((?:[^()'\"@/]|<str>|<comment>|<self>)*\\)/.source, 2);\n    var square = nested(/\\[(?:[^\\[\\]'\"@/]|<str>|<comment>|<self>)*\\]/.source, 2);\n    var curly = nested(/\\{(?:[^{}'\"@/]|<str>|<comment>|<self>)*\\}/.source, 2);\n    var angle = nested(/<(?:[^<>'\"@/]|<str>|<comment>|<self>)*>/.source, 2); // Note about the above bracket patterns:\n    // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and\n    // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which\n    // messes up the bracket and string counting implemented by the above patterns.\n    //\n    // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect\n    // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the\n    // complexity of an HTML expression.\n    //\n    // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also\n    // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.\n\n    var tagAttrs = /(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?/.source;\n    var tagContent = /(?!\\d)[^\\s>\\/=$<%]+/.source + tagAttrs + /\\s*\\/?>/.source;\n    var tagRegion = /\\B@?/.source + '(?:' + /<([a-zA-Z][\\w:]*)/.source + tagAttrs + /\\s*>/.source + '(?:' + (/[^<]/.source + '|' + // all tags that are not the start tag\n    // eslint-disable-next-line regexp/strict\n    /<\\/?(?!\\1\\b)/.source + tagContent + '|' + // nested start tag\n    nested( // eslint-disable-next-line regexp/strict\n    /<\\1/.source + tagAttrs + /\\s*>/.source + '(?:' + (/[^<]/.source + '|' + // all tags that are not the start tag\n    // eslint-disable-next-line regexp/strict\n    /<\\/?(?!\\1\\b)/.source + tagContent + '|' + '<self>') + ')*' + // eslint-disable-next-line regexp/strict\n    /<\\/\\1\\s*>/.source, 2)) + ')*' + // eslint-disable-next-line regexp/strict\n    /<\\/\\1\\s*>/.source + '|' + /</.source + tagContent + ')'; // Now for the actual language definition(s):\n    //\n    // Razor as a language has 2 parts:\n    //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.\n    //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.\n    //\n    // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each\n    // other. However, only CSHTML will be exported via `Prism.languages`.\n\n    Prism.languages.cshtml = Prism.languages.extend('markup', {});\n    var csharpWithHtml = Prism.languages.insertBefore('csharp', 'string', {\n      html: {\n        pattern: RegExp(tagRegion),\n        greedy: true,\n        inside: Prism.languages.cshtml\n      }\n    }, {\n      csharp: Prism.languages.extend('csharp', {})\n    });\n    var cs = {\n      pattern: /\\S[\\s\\S]*/,\n      alias: 'language-csharp',\n      inside: csharpWithHtml\n    };\n    Prism.languages.insertBefore('cshtml', 'prolog', {\n      'razor-comment': {\n        pattern: /@\\*[\\s\\S]*?\\*@/,\n        greedy: true,\n        alias: 'comment'\n      },\n      block: {\n        pattern: RegExp(/(^|[^@])@/.source + '(?:' + [// @{ ... }\n        curly, // @code{ ... }\n        /(?:code|functions)\\s*/.source + curly, // @for (...) { ... }\n        /(?:for|foreach|lock|switch|using|while)\\s*/.source + round + /\\s*/.source + curly, // @do { ... } while (...);\n        /do\\s*/.source + curly + /\\s*while\\s*/.source + round + /(?:\\s*;)?/.source, // @try { ... } catch (...) { ... } finally { ... }\n        /try\\s*/.source + curly + /\\s*catch\\s*/.source + round + /\\s*/.source + curly + /\\s*finally\\s*/.source + curly, // @if (...) {...} else if (...) {...} else {...}\n        /if\\s*/.source + round + /\\s*/.source + curly + '(?:' + /\\s*else/.source + '(?:' + /\\s+if\\s*/.source + round + ')?' + /\\s*/.source + curly + ')*'].join('|') + ')'),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w*/,\n          csharp: cs\n        }\n      },\n      directive: {\n        pattern: /^([ \\t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\\s).*/m,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w+/,\n          csharp: cs\n        }\n      },\n      value: {\n        pattern: RegExp(/(^|[^@])@/.source + /(?:await\\b\\s*)?/.source + '(?:' + /\\w+\\b/.source + '|' + round + ')' + '(?:' + /[?!]?\\.\\w+\\b/.source + '|' + round + '|' + square + '|' + angle + round + ')*'),\n        lookbehind: true,\n        greedy: true,\n        alias: 'variable',\n        inside: {\n          keyword: /^@/,\n          csharp: cs\n        }\n      },\n      'delegate-operator': {\n        pattern: /(^|[^@])@(?=<)/,\n        lookbehind: true,\n        alias: 'operator'\n      }\n    });\n    Prism.languages.razor = Prism.languages.cshtml;\n  })(Prism);\n}","'use strict';\n\nmodule.exports = csharp;\ncsharp.displayName = 'csharp';\ncsharp.aliases = ['dotnet', 'cs'];\n\nfunction csharp(Prism) {\n  ;\n\n  (function (Prism) {\n    /**\n     * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n     *\n     * Note: This is a simple text based replacement. Be careful when using backreferences!\n     *\n     * @param {string} pattern the given pattern.\n     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\n     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\n     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n     */\n    function replace(pattern, replacements) {\n      return pattern.replace(/<<(\\d+)>>/g, function (m, index) {\n        return '(?:' + replacements[+index] + ')';\n      });\n    }\n    /**\n     * @param {string} pattern\n     * @param {string[]} replacements\n     * @param {string} [flags]\n     * @returns {RegExp}\n     */\n\n\n    function re(pattern, replacements, flags) {\n      return RegExp(replace(pattern, replacements), flags || '');\n    }\n    /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */\n\n\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<<self>>/g, function () {\n          return '(?:' + pattern + ')';\n        });\n      }\n\n      return pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]');\n    } // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\n\n\n    var keywordKinds = {\n      // keywords which represent a return or variable type\n      type: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',\n      // keywords which are used to declare a type\n      typeDeclaration: 'class enum interface record struct',\n      // contextual keywords\n      // (\"var\" and \"dynamic\" are missing because they are used like types)\n      contextual: 'add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)',\n      // all other keywords\n      other: 'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield'\n    }; // keywords\n\n    function keywordsToPattern(words) {\n      return '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b';\n    }\n\n    var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n    var keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other));\n    var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other);\n    var nonContextualKeywords = keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.other); // types\n\n    var generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\n\n    var nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n    var name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n    var genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [name, generic]);\n    var identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);\n    var array = /\\[\\s*(?:,\\s*)*\\]/.source;\n    var typeExpressionWithoutTuple = replace(/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source, [identifier, array]);\n    var tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);\n    var tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [tupleElement]);\n    var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [tuple, identifier, array]);\n    var typeInside = {\n      keyword: keywords,\n      punctuation: /[<>()?,.:[\\]]/\n    }; // strings & characters\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\n\n    var character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source; // simplified pattern\n\n    var regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n    var verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n    Prism.languages.csharp = Prism.languages.extend('clike', {\n      string: [{\n        pattern: re(/(^|[^$\\\\])<<0>>/.source, [verbatimString]),\n        lookbehind: true,\n        greedy: true\n      }, {\n        pattern: re(/(^|[^@$\\\\])<<0>>/.source, [regularString]),\n        lookbehind: true,\n        greedy: true\n      }],\n      'class-name': [{\n        // Using static\n        // using static System.Math;\n        pattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [identifier]),\n        lookbehind: true,\n        inside: typeInside\n      }, {\n        // Using alias (type)\n        // using Project = PC.MyCompany.Project;\n        pattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [name, typeExpression]),\n        lookbehind: true,\n        inside: typeInside\n      }, {\n        // Using alias (alias)\n        // using Project = PC.MyCompany.Project;\n        pattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [name]),\n        lookbehind: true\n      }, {\n        // Type declarations\n        // class Foo<A, B>\n        // interface Foo<out A, B>\n        pattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),\n        lookbehind: true,\n        inside: typeInside\n      }, {\n        // Single catch exception declaration\n        // catch(Foo)\n        // (things like catch(Foo e) is covered by variable declaration)\n        pattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [identifier]),\n        lookbehind: true,\n        inside: typeInside\n      }, {\n        // Name of the type parameter of generic constraints\n        // where Foo : class\n        pattern: re(/(\\bwhere\\s+)<<0>>/.source, [name]),\n        lookbehind: true\n      }, {\n        // Casts and checks via as and is.\n        // as Foo<A>, is Bar<B>\n        // (things like if(a is Foo b) is covered by variable declaration)\n        pattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [typeExpressionWithoutTuple]),\n        lookbehind: true,\n        inside: typeInside\n      }, {\n        // Variable, field and parameter declaration\n        // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n        pattern: re(/\\b<<0>>(?=\\s+(?!<<1>>|with\\s*\\{)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source, [typeExpression, nonContextualKeywords, name]),\n        inside: typeInside\n      }],\n      keyword: keywords,\n      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n      number: /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\n      operator: />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n      punctuation: /\\?\\.?|::|[{}[\\];(),.:]/\n    });\n    Prism.languages.insertBefore('csharp', 'number', {\n      range: {\n        pattern: /\\.\\./,\n        alias: 'operator'\n      }\n    });\n    Prism.languages.insertBefore('csharp', 'punctuation', {\n      'named-parameter': {\n        pattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [name]),\n        lookbehind: true,\n        alias: 'punctuation'\n      }\n    });\n    Prism.languages.insertBefore('csharp', 'class-name', {\n      namespace: {\n        // namespace Foo.Bar {}\n        // using Foo.Bar;\n        pattern: re(/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source, [name]),\n        lookbehind: true,\n        inside: {\n          punctuation: /\\./\n        }\n      },\n      'type-expression': {\n        // default(Foo), typeof(Foo<Bar>), sizeof(int)\n        pattern: re(/(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/.source, [nestedRound]),\n        lookbehind: true,\n        alias: 'class-name',\n        inside: typeInside\n      },\n      'return-type': {\n        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n        // int Foo => 0; int Foo { get; set } = 0;\n        pattern: re(/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [typeExpression, identifier]),\n        inside: typeInside,\n        alias: 'class-name'\n      },\n      'constructor-invocation': {\n        // new List<Foo<Bar[]>> { }\n        pattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [typeExpression]),\n        lookbehind: true,\n        inside: typeInside,\n        alias: 'class-name'\n      },\n\n      /*'explicit-implementation': {\n      // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\n      pattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\n      inside: classNameInside,\n      alias: 'class-name'\n      },*/\n      'generic-method': {\n        // foo<Bar>()\n        pattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [name, generic]),\n        inside: {\n          function: re(/^<<0>>/.source, [name]),\n          generic: {\n            pattern: RegExp(generic),\n            alias: 'class-name',\n            inside: typeInside\n          }\n        }\n      },\n      'type-list': {\n        // The list of types inherited or of generic constraints\n        // class Foo<F> : Bar, IList<FooBar>\n        // where F : Bar, IList<int>\n        pattern: re(/\\b((?:<<0>>\\s+<<1>>|record\\s+<<1>>\\s*<<5>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>|<<1>>\\s*<<5>>|<<6>>)(?:\\s*,\\s*(?:<<3>>|<<4>>|<<6>>))*(?=\\s*(?:where|[{;]|=>|$))/.source, [typeDeclarationKeywords, genericName, name, typeExpression, keywords.source, nestedRound, /\\bnew\\s*\\(\\s*\\)/.source]),\n        lookbehind: true,\n        inside: {\n          'record-arguments': {\n            pattern: re(/(^(?!new\\s*\\()<<0>>\\s*)<<1>>/.source, [genericName, nestedRound]),\n            lookbehind: true,\n            greedy: true,\n            inside: Prism.languages.csharp\n          },\n          keyword: keywords,\n          'class-name': {\n            pattern: RegExp(typeExpression),\n            greedy: true,\n            inside: typeInside\n          },\n          punctuation: /[,()]/\n        }\n      },\n      preprocessor: {\n        pattern: /(^[\\t ]*)#.*/m,\n        lookbehind: true,\n        alias: 'property',\n        inside: {\n          // highlight preprocessor directives as keywords\n          directive: {\n            pattern: /(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\n            lookbehind: true,\n            alias: 'keyword'\n          }\n        }\n      }\n    }); // attributes\n\n    var regularStringOrCharacter = regularString + '|' + character;\n    var regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source, [regularStringOrCharacter]);\n    var roundExpression = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]), 2); // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\n\n    var attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\n    var attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [identifier, roundExpression]);\n    Prism.languages.insertBefore('csharp', 'class-name', {\n      attribute: {\n        // Attributes\n        // [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\n        pattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/.source, [attrTarget, attr]),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          target: {\n            pattern: re(/^<<0>>(?=\\s*:)/.source, [attrTarget]),\n            alias: 'keyword'\n          },\n          'attribute-arguments': {\n            pattern: re(/\\(<<0>>*\\)/.source, [roundExpression]),\n            inside: Prism.languages.csharp\n          },\n          'class-name': {\n            pattern: RegExp(identifier),\n            inside: {\n              punctuation: /\\./\n            }\n          },\n          punctuation: /[:,]/\n        }\n      }\n    }); // string interpolation\n\n    var formatString = /:[^}\\r\\n]+/.source; // multi line\n\n    var mInterpolationRound = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]), 2);\n    var mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [mInterpolationRound, formatString]); // single line\n\n    var sInterpolationRound = nested(replace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [regularStringOrCharacter]), 2);\n    var sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [sInterpolationRound, formatString]);\n\n    function createInterpolationInside(interpolation, interpolationRound) {\n      return {\n        interpolation: {\n          pattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [interpolation]),\n          lookbehind: true,\n          inside: {\n            'format-string': {\n              pattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [interpolationRound, formatString]),\n              lookbehind: true,\n              inside: {\n                punctuation: /^:/\n              }\n            },\n            punctuation: /^\\{|\\}$/,\n            expression: {\n              pattern: /[\\s\\S]+/,\n              alias: 'language-csharp',\n              inside: Prism.languages.csharp\n            }\n          }\n        },\n        string: /[\\s\\S]+/\n      };\n    }\n\n    Prism.languages.insertBefore('csharp', 'string', {\n      'interpolation-string': [{\n        pattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source, [mInterpolation]),\n        lookbehind: true,\n        greedy: true,\n        inside: createInterpolationInside(mInterpolation, mInterpolationRound)\n      }, {\n        pattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [sInterpolation]),\n        lookbehind: true,\n        greedy: true,\n        inside: createInterpolationInside(sInterpolation, sInterpolationRound)\n      }],\n      char: {\n        pattern: RegExp(character),\n        greedy: true\n      }\n    });\n    Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n  })(Prism);\n}"],"sourceRoot":""}