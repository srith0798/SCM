{"version":3,"sources":["../node_modules/refractor/lang/tsx.js","../node_modules/refractor/lang/typescript.js","../node_modules/refractor/lang/jsx.js"],"names":["refractorJsx","refractorTypescript","tsx","Prism","register","typescript","util","clone","languages","extend","tag","pattern","RegExp","source","flags","lookbehind","module","exports","displayName","aliases","greedy","inside","builtin","keyword","push","typeInside","insertBefore","decorator","at","alias","function","generic","ts","jsx","javascript","space","braces","spread","re","replace","script","rest","stringifyToken","token","content","map","join","hooks","add","env","language","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","openedBraces","plainText","splice","Token"],"mappings":"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","file":"static/js/react-syntax-highlighter_languages_refractor_tsx.e20c10d0.chunk.js","sourcesContent":["'use strict';\n\nvar refractorJsx = require('./jsx.js');\n\nvar refractorTypescript = require('./typescript.js');\n\nmodule.exports = tsx;\ntsx.displayName = 'tsx';\ntsx.aliases = [];\n\nfunction tsx(Prism) {\n  Prism.register(refractorJsx);\n  Prism.register(refractorTypescript);\n\n  (function (Prism) {\n    var typescript = Prism.util.clone(Prism.languages.typescript);\n    Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // This will prevent collisions between TSX tags and TS generic types.\n    // Idea by https://github.com/karlhorky\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n\n    var tag = Prism.languages.tsx.tag;\n    tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\n    tag.lookbehind = true;\n  })(Prism);\n}","'use strict';\n\nmodule.exports = typescript;\ntypescript.displayName = 'typescript';\ntypescript.aliases = ['ts'];\n\nfunction typescript(Prism) {\n  ;\n\n  (function (Prism) {\n    Prism.languages.typescript = Prism.languages.extend('javascript', {\n      'class-name': {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      },\n      builtin: /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/\n    }); // The keywords TypeScript adds to JavaScript\n\n    Prism.languages.typescript.keyword.push(/\\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n    /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, // This is for `import type *, {}`\n    /\\btype\\b(?=\\s*(?:[\\{*]|$))/); // doesn't work with TS because TS is too complex\n\n    delete Prism.languages.typescript['parameter']; // a version of typescript specifically for highlighting types\n\n    var typeInside = Prism.languages.extend('typescript', {});\n    delete typeInside['class-name'];\n    Prism.languages.typescript['class-name'].inside = typeInside;\n    Prism.languages.insertBefore('typescript', 'function', {\n      decorator: {\n        pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n        inside: {\n          at: {\n            pattern: /^@/,\n            alias: 'operator'\n          },\n          function: /^[\\s\\S]+/\n        }\n      },\n      'generic-function': {\n        // e.g. foo<T extends \"bar\" | \"baz\">( ...\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n        greedy: true,\n        inside: {\n          function: /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n          generic: {\n            pattern: /<[\\s\\S]+/,\n            // everything after the first <\n            alias: 'class-name',\n            inside: typeInside\n          }\n        }\n      }\n    });\n    Prism.languages.ts = Prism.languages.typescript;\n  })(Prism);\n}","'use strict';\n\nmodule.exports = jsx;\njsx.displayName = 'jsx';\njsx.aliases = [];\n\nfunction jsx(Prism) {\n  ;\n\n  (function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript);\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n    /**\n     * @param {string} source\n     * @param {string} [flags]\n     */\n\n    function re(source, flags) {\n      source = source.replace(/<S>/g, function () {\n        return space;\n      }).replace(/<BRACES>/g, function () {\n        return braces;\n      }).replace(/<SPREAD>/g, function () {\n        return spread;\n      });\n      return RegExp(source, flags);\n    }\n\n    spread = re(spread).source;\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n    Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\n    Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/i;\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n    Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n    Prism.languages.insertBefore('inside', 'attr-name', {\n      spread: {\n        pattern: re(/<SPREAD>/.source),\n        inside: Prism.languages.jsx\n      }\n    }, Prism.languages.jsx.tag);\n    Prism.languages.insertBefore('inside', 'special-attr', {\n      script: {\n        // Allow for two levels of nesting\n        pattern: re(/=<BRACES>/.source),\n        inside: {\n          'script-punctuation': {\n            pattern: /^=(?=\\{)/,\n            alias: 'punctuation'\n          },\n          rest: Prism.languages.jsx\n        },\n        alias: 'language-javascript'\n      }\n    }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n    var stringifyToken = function stringifyToken(token) {\n      if (!token) {\n        return '';\n      }\n\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function walkTokens(tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}"],"sourceRoot":""}