{"version":3,"sources":["../node_modules/refractor/lang/http.js"],"names":["http","Prism","headerValueOf","name","RegExp","languages","pattern","inside","method","alias","lookbehind","uri","header","source","csp","hpkp","hsts","punctuation","options","langs","httpLanguages","javascript","json","xml","html","css","plain","suffixTypes","getSuffixPattern","contentType","suffix","replace","insertBefore","module","exports","displayName","aliases"],"mappings":"yHAMA,SAASA,EAAKC,IAGZ,SAAWA,GAKT,SAASC,EAAcC,GACrB,OAAOC,OAAO,QAAUD,EAAO,yBAA0B,KAG3DF,EAAMI,UAAUL,KAAO,CACrB,eAAgB,CACdM,QAAS,6GACTC,OAAQ,CAENC,OAAQ,CACNF,QAAS,YACTG,MAAO,YAGT,iBAAkB,CAChBH,QAAS,mCACTI,YAAY,EACZD,MAAO,MACPF,OAAQN,EAAMI,UAAUM,KAG1B,eAAgB,CACdL,QAAS,oBACTI,YAAY,EACZD,MAAO,cAIb,kBAAmB,CACjBH,QAAS,wBACTC,OAAQ,CAEN,eAAgB,CACdD,QAAS,gBACTG,MAAO,YAGT,cAAe,CACbH,QAAS,iBACTI,YAAY,EACZD,MAAO,UAGT,gBAAiB,CACfH,QAAS,UACTI,YAAY,EACZD,MAAO,YAIbG,OAAQ,CACNN,QAAS,sCACTC,OAAQ,CACN,eAAgB,CAAC,CACfD,QAASJ,EAAc,0BAA0BW,QACjDH,YAAY,EACZD,MAAO,CAAC,MAAO,iBACfF,OAAQN,EAAMI,UAAUS,KACvB,CACDR,QAASJ,EAAc,mCAAmCW,QAC1DH,YAAY,EACZD,MAAO,CAAC,OAAQ,kBAChBF,OAAQN,EAAMI,UAAUU,MACvB,CACDT,QAASJ,EAAc,4BAA4BW,QACnDH,YAAY,EACZD,MAAO,CAAC,OAAQ,kBAChBF,OAAQN,EAAMI,UAAUW,MACvB,CACDV,QAASJ,EAAc,QAAQW,QAC/BH,YAAY,IAEd,cAAe,CACbJ,QAAS,SACTG,MAAO,WAETQ,YAAa,QAKnB,IA8BIC,EA9BAC,EAAQlB,EAAMI,UACde,EAAgB,CAClB,yBAA0BD,EAAME,WAChC,mBAAoBF,EAAMG,MAAQH,EAAME,WACxC,kBAAmBF,EAAMI,IACzB,WAAYJ,EAAMI,IAClB,YAAaJ,EAAMK,KACnB,WAAYL,EAAMM,IAClB,aAAcN,EAAMO,OAGlBC,EAAc,CAChB,oBAAoB,EACpB,mBAAmB,GASrB,SAASC,EAAiBC,GACxB,IAAIC,EAASD,EAAYE,QAAQ,YAAa,IAE9C,MAAO,MAAQF,EAAc,KADT,wBAA0BC,EAAS,gBACJ,IAOrD,IAAK,IAAID,KAAeT,EACtB,GAAIA,EAAcS,GAAc,CAC9BX,EAAUA,GAAW,GACrB,IAAIZ,EAAUqB,EAAYE,GAAeD,EAAiBC,GAAeA,EACzEX,EAAQW,EAAYE,QAAQ,MAAO,MAAQ,CACzCzB,QAASF,OAAO,IAAM,mBAAmBS,OAASP,EAAU,iDAAiDO,OAAS,IAKtH,mBAAmBA,OAAQ,KAC3BH,YAAY,EACZH,OAAQa,EAAcS,IAKxBX,GACFjB,EAAMI,UAAU2B,aAAa,OAAQ,SAAUd,GAxInD,CA0IGjB,GAjJLgC,EAAOC,QAAUlC,EACjBA,EAAKmC,YAAc,OACnBnC,EAAKoC,QAAU","file":"static/js/react-syntax-highlighter_languages_refractor_http.dbc7c922.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = http;\nhttp.displayName = 'http';\nhttp.aliases = [];\n\nfunction http(Prism) {\n  ;\n\n  (function (Prism) {\n    /**\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function headerValueOf(name) {\n      return RegExp('(^(?:' + name + '):[ \\t]*(?![ \\t]))[^]+', 'i');\n    }\n\n    Prism.languages.http = {\n      'request-line': {\n        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\n        inside: {\n          // HTTP Method\n          method: {\n            pattern: /^[A-Z]+\\b/,\n            alias: 'property'\n          },\n          // Request Target e.g. http://example.com, /path/to/file\n          'request-target': {\n            pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n            lookbehind: true,\n            alias: 'url',\n            inside: Prism.languages.uri\n          },\n          // HTTP Version\n          'http-version': {\n            pattern: /^(\\s)HTTP\\/[\\d.]+/,\n            lookbehind: true,\n            alias: 'property'\n          }\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\n        inside: {\n          // HTTP Version\n          'http-version': {\n            pattern: /^HTTP\\/[\\d.]+/,\n            alias: 'property'\n          },\n          // Status Code\n          'status-code': {\n            pattern: /^(\\s)\\d+(?=\\s)/,\n            lookbehind: true,\n            alias: 'number'\n          },\n          // Reason Phrase\n          'reason-phrase': {\n            pattern: /^(\\s).+/,\n            lookbehind: true,\n            alias: 'string'\n          }\n        }\n      },\n      header: {\n        pattern: /^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,\n        inside: {\n          'header-value': [{\n            pattern: headerValueOf(/Content-Security-Policy/.source),\n            lookbehind: true,\n            alias: ['csp', 'languages-csp'],\n            inside: Prism.languages.csp\n          }, {\n            pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\n            lookbehind: true,\n            alias: ['hpkp', 'languages-hpkp'],\n            inside: Prism.languages.hpkp\n          }, {\n            pattern: headerValueOf(/Strict-Transport-Security/.source),\n            lookbehind: true,\n            alias: ['hsts', 'languages-hsts'],\n            inside: Prism.languages.hsts\n          }, {\n            pattern: headerValueOf(/[^:]+/.source),\n            lookbehind: true\n          }],\n          'header-name': {\n            pattern: /^[^:]+/,\n            alias: 'keyword'\n          },\n          punctuation: /^:/\n        }\n      }\n    }; // Create a mapping of Content-Type headers to language definitions\n\n    var langs = Prism.languages;\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css,\n      'text/plain': langs.plain\n    }; // Declare which types can also be suffixes\n\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    };\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '');\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])';\n      return '(?:' + contentType + '|' + suffixPattern + ')';\n    } // Insert each content type parser that has its associated language\n    // currently loaded.\n\n\n    var options;\n\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {};\n        var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;\n        options[contentType.replace(/\\//g, '-')] = {\n          pattern: RegExp('(' + /content-type:\\s*/.source + pattern + /(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source + ')' + // This is a little interesting:\n          // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\n          // However, when writing code by hand (e.g. to display on a website) people can forget about this,\n          // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\n          // the body does not start with a [\\w-] character (as headers do).\n          /[^ \\t\\w-][\\s\\S]*/.source, 'i'),\n          lookbehind: true,\n          inside: httpLanguages[contentType]\n        };\n      }\n    }\n\n    if (options) {\n      Prism.languages.insertBefore('http', 'header', options);\n    }\n  })(Prism);\n}"],"sourceRoot":""}